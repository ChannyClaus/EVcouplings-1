"""
Code for identifying Pfam domains and mapping Pfam
alignments and ECs into target sequence mode.

Authors:
  Thomas A. Hopf

# TODO: write code to create list of family sizes
# TODO: implement alignments against Pfam-HMM so
        precomputed results can be reused in
        focus mode
"""
import pandas as pd
from evcouplings.align.tools import run_hmmscan, read_hmmer_domtbl
from evcouplings.utils.helpers import range_overlap


def create_family_size_table(full_pfam_file):
    """
    Parse family size table from Pfam flat file
    (ftp://ftp.ebi.ac.uk/pub/databases/Pfam/current_release/Pfam-A.full.gz)

    Parameters
    ----------
    full_pfam_file : file-like object

    # TODO: implement this. Output format should be a csv file
            with two columns, pfam_id and num_seqs

            A similar file can be currently generated using
            /groups/marks/databases/pfam/create_pfam_size_table.pl

            and converted using:

            sizes = pd.read_csv(
                "size_table.txt",
                sep="\t",
                names=["pfam_id", "num_seqs"]
            )
            sizes.to_csv("size_table.csv", index=False)
    """
    raise NotImplementedError()


def remove_clan_overlaps(pfam_table):
    """
    Remove overlapping Pfam hits from same Pfam clan
    (equivalent of PfamScan.pl). Currently only
    allows to remove overlaps by domain bitscore.

    # TODO: is bitscore the most sensible choice if different length hits?

    Parameters
    ----------
    pfam_table : pd.DataFrame
        Pfam hit table as generated by pfam_hits() function
        (must contain Pfam clan annotation).

    Returns
    -------
    pd.DataFrame
        Pfam hit table with lower-scoring overlaps removed
    """
    # could make this a parameter, if switching to E-values
    # we would have to changing sorting order of DataFrame
    # and sign of comparison further below.
    score = "domain_score"

    # group by sequence ID and clan to resolve overlaps
    grouped = pfam_table.sort_values(
        by=score, ascending=False
    ).groupby(
        by=["query_name", "clan_id"], as_index=False, sort=False
    )

    # store index value of all entries to discard
    remove_hits = []

    for (uniprot_ac, clan_name), grp in grouped:
        # safety check here that we are not grouping hits that are
        # not in the same clan (missing value) if pandas ever changed
        # the behaviour of groupby to not iterate through groups
        # with missing values. Otherwise, we would have to skip grouop.
        assert clan_name.startswith("CL")

        # go through all pairwise combinations of hits
        for idx1, hit1 in grp.iterrows():
            for idx2, hit2 in grp.iterrows():
                if idx1 < idx2:
                    if range_overlap(
                        (int(hit1["ali_from"]), int(hit1["ali_to"]) + 1),
                        (int(hit2["ali_from"]), int(hit2["ali_to"]) + 1),
                    ) > 0:
                        if float(hit1[score]) >= float(hit2[score]):
                            remove_hits.append(idx2)
                        else:
                            remove_hits.append(idx1)

    return pfam_table.loc[~pfam_table.index.isin(remove_hits)]


def pfam_hits(query_file, hmm_database, prefix,
              clan_table_file, size_table_file,
              resolve_overlaps=True,
              hmmscan_binary="hmmscan"):
    """
    Identify hits of Pfam HMMs in a set of sequences.

    Parameters
    ----------
    query_file : str
        File containing query sequence(s)
    hmm_database : str
        File containing HMM database
        (Pfam-A.hmm, with hmmpress applied)
    prefix : str
        Prefix path for output files. Folder structure in
        the prefix will be created if not existing.
    clan_table_file : str
        File with table linking Pfam families to clans
        (Pfam-A.clans.tsv). Set to None if not available,
        but resolve_overlaps cannot be True in that case.
    size_table_file : str
        File with table of family sizes. Create using
        create_family_size_table(). Set to None if not
        available.
    resolve_overlaps : bool
        Resolve overlapping hits by families from
        the same clan.
        Only possible if clan_table_file is given.
    hmmscan_binary : str (default: "hmmscan")
        Path to hmmscan binary (put in PATH for
        default to work)

    Returns
    -------
    pd.DataFrame
        Pfam hit table
    """
    # find HMM hits with hmmscan
    scan_res = run_hmmscan(
        query_file, hmm_database, prefix,
        binary=hmmscan_binary
    )

    hits = read_hmmer_domtbl(scan_res.domtblout)

    # remove version information from family name
    hits.loc[:, "pfam_id"] = hits.target_accession.map(
        lambda x: x.split(".")[0]
    )

    # add information about Pfam clan for each family,
    # this is necessary to resolve overlapping hits
    # clan file is Pfam-A.clans.tsv from Pfam FTP site
    if clan_table_file is not None:
        clans = pd.read_csv(
            clan_table_file, sep="\t",
            names=[
                "pfam_id", "clan_id", "clan_name",
                "family_name", "family_text"
            ]
        )

        hits = hits.merge(clans, on="pfam_id", how="left")

    # add number of sequences in each Pfam family,
    # this file has to be created using create_family_sie_table()
    # from Pfam-A.full.gz flatfile
    if size_table_file is not None:
        sizes = pd.read_csv(size_table_file)
        hits = hits.merge(sizes, on="pfam_id", how="left")

        hits.loc[:, "num_seqs_over_len"] = (
            hits.loc[:, "num_seqs"] /
            pd.to_numeric(hits.loc[:, "target_len"], errors="raise")
        )

    # multiple members of the same clan might hit overlapping regions
    # in these cases, we may only want to keep the top-scoring hit
    if resolve_overlaps:
        if clan_table_file is None:
            raise ValueError(
                "Need to specify clan_table_file to resolve "
                "overlapping hits from same clan."
            )

        hits = remove_clan_overlaps(hits)

    return hits
