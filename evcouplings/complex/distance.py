"""
Protocols for concatenating sequences based
on distance in genome

Authors:
  Anna G. Green
  Thomas A. Hopf
  Charlotta P.I. Sch√§rfe
"""
from collections import defaultdict
from operator import itemgetter
import pandas as pd

def get_distance(annotation1, annotation2):
    """
    Compute distance between two CDS locations on
    the same genome
    
    Parameters
    ----------
    annotation1 : tuple of (str, str, int, int)
        EMBL annotation for first CDS in the format
        (genome_id, uniprot_ac, genome_start, genome_end)
    annotation2 : tuple of (str, str, int, int)
        EMBL annotation for second CDS
        
    Returns
    -------
    int
        Distance between gene 1 and gene 2 on the
        ENA genome
    """
    # extract the two locations from the annotation
    # sort each so that smaller genome position is first
    location_1 = sorted(
        (annotation1[2], annotation1[3])
    )

    location_2 = sorted(
        (annotation2[2], annotation2[3])
    )

    # sort the two annotations so that the one with
    # an earlier start site is first
    x, y = sorted((location_1, location_2))

    # if not overlapping, calculate the distance
    if x[0] <= x[1] < y[0]:
        return y[0] - x[1]

    # if overlapping, return 0
    return 0


def best_reciprocal_matching(possible_partners):
    """
    Amongst all possible pairings of CDSs, finds
    those where both sequences are closest neighbors
    to each other

    Parameters
    ----------
    possible_partners: dict of list of (str,int) tuples
        Generated by the find_possible_partners function.
        For each uniprot identifier in the first alignment,
        gives all of the uniprot identifiers in the second
        alignment found in the same genome, and the number of
        nucleotides between the two coding DNA sequences that
        correspond to the pair of uniprot IDs

    Returns
    -------
    dict of tuple:int
        For each pair of uniprot identifiers that are reciprocally
        closest to one another on a genome, the genome distance in
        nucleotides between the corresponding CDSs

    """

    # create a reverse matching of sequences (from 2nd alignment sequences to 1st alignment sequences)
    reverse_partners = defaultdict(list)
    for uniprot_id_1 in possible_partners:
        for uniprot_id_2, genome_distance in possible_partners[uniprot_id_1]:
            reverse_partners[uniprot_id_2].append((uniprot_id_1, genome_distance))

    id_pairing = {}

    # look at all sequences in first alignment, and check their possible partners
    for uniprot_id_1 in possible_partners:

        # what is the closest sequence in second alignment wrt to genome distance?
        closest_to_uniprot_1 = sorted(possible_partners[uniprot_id_1], key=itemgetter(1))[0][0]

        # find the closest sequence in first alignment to the above sequence in second alignment
        closest_to_uniprot_2 = sorted(reverse_partners[closest_to_uniprot_1], key=itemgetter(1))[0][0]

        # check if matched sequences are reciprocally the closest on the genome
        if closest_to_uniprot_2 == uniprot_id_1:
            distance = sorted(possible_partners[uniprot_id_1], key=itemgetter(1))[0][1]
            id_pairing[(uniprot_id_1, closest_to_uniprot_1)] = distance

    return id_pairing

def find_possible_partners(seq_ids_ali_1, seq_ids_ali_2,
                           gene_location_table_1, gene_location_table_2):
    """
    Constructs a dictionary of all possible sequence pairings
    between the two monomer alignments

    Parameters
    ----------
    seq_ids_ali_1: list of str
        Uniprot ACs for entries in first alignment
    seq_ids_ali_2: list of str
        Uniprot ACs for entries in second alignment
    gene_location_table_1: pd.DataFrame
        dataframe of gene locations for the first
        protein, generated by extract_embl_annotation
    gene_location_table_2: pd.DataFrame
        dataframe of gene locations for the second
        protein, generated by extract_embl_annotation

    Returns
    -------
    dict of tuples of (str,int)
        uniprot_id_1:[(uniprot_id_2_A:genome_distance_A),
                      (uniprot_id_2_B:genome_distance_B)]
        For each uniprot identifier in the first alignment,
        gives all of the uniprot identifiers in the second
        alignment found in the same genome, and the number of
        nucleotides between the two coding DNA sequences that
        correspond to the pair of uniprot IDs
    """

    possible_partners = defaultdict(list)

    # drop any rows that are missing location information for the CDS
    gene_location_table_1.dropna(axis=0, inplace=True)
    gene_location_table_2.dropna(axis=0, inplace=True)

    # drop duplicate rows - speeds up calculation
    gene_location_table_1.drop_duplicates(inplace=True)
    gene_location_table_2.drop_duplicates(inplace=True)

    # iterate over EMBL genomes found in the first alignment
    for genome in list(gene_location_table_1.genome_id):

        # If we found a hit to that genome in the second alignment
        if genome in list(gene_location_table_2.genome_id):

            # get subsets of the dataframe corresponding to the current genome
            gene_location_subset_1 = gene_location_table_1.query("genome_id == @genome")
            gene_location_subset_2 = gene_location_table_2.query("genome_id == @genome")

            # compare all pairs of CDSs corresponding to the two proteins
            # that originate from the current genome
            # find the distances between all pairs
            for idx1 in gene_location_subset_1.index:
                for idx2 in gene_location_subset_2.index:
                    distance_between_genes = get_distance(
                        (  # location of the first cds
                            gene_location_subset_1.loc[idx1, "gene_start"],
                            gene_location_subset_1.loc[idx1, "gene_end"]
                        ),
                        (  # location of the second cds
                            gene_location_subset_2.loc[idx2, "gene_start"],
                            gene_location_subset_2.loc[idx2, "gene_end"]
                        ),
                    )

                    # get the uniprot ids corresponding to the two CDSs
                    uniprot_id_1 = gene_location_subset_1.loc[idx1, "uniprot_ac"]
                    uniprot_id_2 = gene_location_subset_2.loc[idx2, "uniprot_ac"]

                    possible_partners[uniprot_id_1].append(
                        (uniprot_id_2, distance_between_genes)
                    )

    return possible_partners


def filter_ids_by_distance(id_pairing,
                           id_pair_to_distance,
                           genome_distance_threshold=999999999):
    """
    Filters the list of paired ids to include only those
    below the genome distance threshold

    Parameters
    ----------
    id_pairing: list of tuple
        matched pairs of ids
    id_pair_to_distance: dict of tuple:int
        genome distance between pairs
    genome_distance_threshold: int
        maximum distance on genome allowed

    Returns
    -------
    filtered_id_pairing: list of tuple
        matched pairs of ids that are closer than 
        the threshold        
    """
    filtered_id_pairing = []

    # TODO: default parameter for genome_distance_threshold should be None
    for id_pair in id_pairing:
        if id_pair in id_pair_to_distance and \
                        id_pair_to_distance[id_pair] <= genome_distance_threshold:
            filtered_id_pairing.append(id_pair)

    return filtered_id_pairing


def plot_distance_distribution(id_pair_to_distance,outfile):
    """
    plots the distribution of genome distances
    
    Parameters
    ----------
    id_pair_to_distance: dict of tuple: int
        pairs of identifiers and their distances on the genome
    outfile: str
        path to file to save plot
    """
    
    distances = list(id_pair_to_distance.values())
    distances = sorted(distances)


    cdf = range(len(distances))

    fig = plt.figure(figsize=(8,6))
    ax1 = fig.gca()
    ax1.set_xscale("log")
    ax1.set_xlim(xmin=1,xmax=max(distances))
    ax1.set_ylabel("Number of sequences")
    ax1.set_xlabel("Genome distance (bases)")
    ax1.plot(distances,cdf)
    
    plt.savefig(outfile)
